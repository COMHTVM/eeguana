
mutate <-function (.data, ...) {
    UseMethod("mutate")
}
transmute <-function (.data, ...) {
    UseMethod("transmute")
}
rename <-function (.data, ...) {
    UseMethod("rename")
}

#' @export
select <-function (.data, ...) {
    UseMethod("select")
}

#' Mutate the signal of an eegble.
#'
#' @param .data An eegbl.
#' @param ... Name-value pairs of expressions, tipically they will include channel names.
#' 
#' @return An eegbl. 
#' 
#' @importFrom magrittr %>%
#' 
#' @export
mutate.eegbl <- function(.data, ...){

  dots <-  validate_dots(...)

  .data$data <- dplyr::mutate(.data$data,!!!dots)
  .data <- update_chans(.data)
}            

#' @export
transmute.eegbl <- function(.data, ...){

  dots <-  validate_dots(...)
  
  .data$data <- dplyr::transmute(.data$data,.id, sample, !!!dots)
  .data <- update_chans(.data)
}            


#' @export
select.eegbl <- function(.data, ...){

  dots <-  validate_dots(...)
  
  .data$data <- dplyr::select(.data$data, .id, sample, !!!dots)
  
  .data <- update_chans(.data)
}  


#' @export
rename.eegbl <- function(.data, ...){

  dots <-  validate_dots(...)
  
  .data$data <- dplyr::rename(.data$data, !!!dots)
  
  .data <- update_chans(.data)
}  




# #' Mutate the signal of an eegble.
# #'
# #' @param .data An eegbl.
# #' @param .funs Name-value pairs of expressions, tipically they will include channel names.
# #' @param parallel List of function calls generated by ‘funs()’, or a character
# #'    vector of function names, or simply a function.
# #'    Bare formulas are passed to ‘rlang::as_function()’ to create
# #'    purrr-style lambda functions. Note that these lambda prevent
# #'    hybrid evaluation from happening and it is thus more
# #'    efficient to supply functions like ‘mean()’ directly rather
# #'    than in a lambda-formula.
# #' @param ... Additional arguments for the function calls in ‘.funs’. These 
# #'    are evaluated only once, with explicit splicing.
# #' 
# #' The parallel option runs the process in several cores using \code{furrr} 
# #' with \code{future} as the backends. To use the parallel option these 
# #' packages need to be installed, the library \code{future} needs to be 
# #' attached, and a "plan" needs to be specified (e.g., 
# #' \code{plan(multiprocess)})
# #' 
# #' @return An eegbl. 
# #' 
# #' @importFrom magrittr %>%
# #' 
# #' @export
# mutate_all.eggbl <- function(.data, .funs,..., parallel = FALSE){

#   dots <- rlang::enquos(...)
#   .funs <- rlang::enquos(.funs)
  
#   if(names(dots) %in% c("time", "sample")) {
#     stop("time and samples can't be overwritten")
#   }

#   f_all <- function(x) {
#     dplyr::mutate_at(x, chan_names(.data), !!!.funs, !!!dots)
#   }
#   segmap_eggbl(x, f_seg = f_all, parallel = parallel)

# }            

