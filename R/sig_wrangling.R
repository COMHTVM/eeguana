
#' Mutate the signal of an eegble.
#'
#' @param .data An eegbl.
#' @param ... Name-value pairs of expressions, tipically they will include channel names.
#' 
#' @return An eegbl. 
#' 
#' @importFrom magrittr %>%
#' 
#' @export
mutate_chan <- function(.data, ...){
  dots <-  validate_dots(...)
  .data$data <- dplyr::mutate(.data$data,!!!dots)
   update_chans(.data)
}            

#' @export
transmute_chan <- function(.data, ...){
  dots <-  validate_dots(...)
  .data$data <- dplyr::transmute(.data$data, sample, !!!dots)
  update_chans(.data)
}            


#' @export
select_chan <- function(.data, ...){
  dots <-  validate_dots(...)
  .data$data <- dplyr::select(.data$data, .id, sample, !!!dots)
  update_chans(.data)
}  


#' @export
rename_chan <- function(.data, ...){
  dots <-  validate_dots(...)
  .data$data <- dplyr::rename(.data$data, !!!dots)
  update_chans(.data)
}  


#' @export
mutate_seg <- function(.data, ...){
   dots <-  validate_dots(...)
  .data$seg_info <- dplyr::mutate(.data$seg_info,!!!dots)
  .data
}   
transmute_seg <- function(.data, ...){
   dots <-  validate_dots(...)
  .data$seg_info <- dplyr::mutate(.data$seg_info, .id, !!!dots)
  .data
}   
#' @export
rename_seg <- function(.data, ...){
   dots <-  validate_dots(...)
  .data$seg_info <- dplyr::rename(.data$seg_info,!!!dots)
  .data
}   
#' @export
select_seg <- function(.data, ...){
   dots <-  validate_dots(...)
  .data$seg_info <- dplyr::select(.data$seg_info, .id, !!!dots)
  .data
}   


# #' Mutate the signal of an eegble.
# #'
# #' @param .data An eegbl.
# #' @param .funs Name-value pairs of expressions, tipically they will include channel names.
# #' @param parallel List of function calls generated by ‘funs()’, or a character
# #'    vector of function names, or simply a function.
# #'    Bare formulas are passed to ‘rlang::as_function()’ to create
# #'    purrr-style lambda functions. Note that these lambda prevent
# #'    hybrid evaluation from happening and it is thus more
# #'    efficient to supply functions like ‘mean()’ directly rather
# #'    than in a lambda-formula.
# #' @param ... Additional arguments for the function calls in ‘.funs’. These 
# #'    are evaluated only once, with explicit splicing.
# #' 
# #' The parallel option runs the process in several cores using \code{furrr} 
# #' with \code{future} as the backends. To use the parallel option these 
# #' packages need to be installed, the library \code{future} needs to be 
# #' attached, and a "plan" needs to be specified (e.g., 
# #' \code{plan(multiprocess)})
# #' 
# #' @return An eegbl. 
# #' 
# #' @importFrom magrittr %>%
# #' 
# #' @export
# mutate_all.eggbl <- function(.data, .funs,..., parallel = FALSE){

#   dots <- rlang::enquos(...)
#   .funs <- rlang::enquos(.funs)
  
#   if(names(dots) %in% c("time", "sample")) {
#     stop("time and samples can't be overwritten")
#   }

#   f_all <- function(x) {
#     dplyr::mutate_at(x, chan_names(.data), !!!.funs, !!!dots)
#   }
#   segmap_eggbl(x, f_seg = f_all, parallel = parallel)

# }            

