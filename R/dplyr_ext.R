#' Rollup summary for the signal table of an eeg_lst.
#' 
#' Summarizes at a specific levels of groupings producing multiple (sub-)totals. It wraps [data.table::rollup()] and returns the summary at a specified grouping level. For more details about `_at` and `_all` functions, see [dplyr::summarise_all()].
#
#'
#' * `rollup()` does a rollup aggregation of grouped `eeg_lst` until the specified level.
#' * `rollup_at_ch()` allows for selecting the channels  using the same name-based select_helpers just like with `select()`.
#' * `rollup_all_ch()` applies the rollup to all channels.
#' 
#' 
#' @param x An eeg_lst object.
#' @param level A character vector of variables that indicate the level of grouping of the rollup.
#' @param .funs List of function calls generated by `funs()`, or a character vector of function names, or simply a function.
#' @param .vars A list of channels  generated by `vars()`, a character vector of channel names, or ‘NULL’.
#' 
#' @family summarizing functions
#' @family dplyr functions
#' 
#' @name rollup
NULL
# > NULL

#' @export
rollup <- data.table::rollup

#' @name rollup
#' @export
rollup_all_ch <- function(x, ...) {
  UseMethod("rollup_all_ch")
}
#' @rdname rollup
#' @export
rollup_at_ch <- function(x,  ...) {
  UseMethod("rollup_at_ch")
}

#' @rdname rollup
#' @export
rollup.eeg_lst <- function(x, ..., level = c()) {
  dots <- rlang::quos(...)
 rollup_eeg_lst(x, dots, level)
}

#' @rdname rollup
#' @export
rollup_at_ch.eeg_lst <- function(x,.vars,  .funs, ..., level = c()) {
  #TODO look for a rlang alternative for dplyr:::as_fun_list and dplyr:::tbl_at_syms
  funs <- dplyr:::as_fun_list(.funs, rlang::enquo(.funs), rlang::caller_env(),...) # fun_list class, contains a quosure such as ^mean(.)
  vars <- dplyr:::tbl_at_syms(x, .vars) #list of chars
  rollup_at_eeg_lst(x, vars, funs, level) 
}

#' @rdname rollup
#' @export
rollup_all_ch.eeg_lst <- function(x, .funs, ..., level = c()) {
  funs <- dplyr:::as_fun_list(.funs, rlang::enquo(.funs), rlang::caller_env(),...) # fun_list class, contains a quosure such as ^mean(.)
  vars <- as.list(channel_names(x))
  rollup_at_eeg_lst(x, vars, funs, level) 
}


#' Summarize multiple channels
#' 
#' These are scoped variants of `summarize()` that apply operations on a selection of channels
#
#'
#' * `summarize_at_ch` allows for selecting the channels  using the same name-based select_helpers just like with `select()`.
#' * `summarize_all_ch` summarizes all channels.
#'
#' @param .tbl An eeg_lst object.
#' 
#' @family summarizing functions
#' @family dplyr functions
#' 
#' @name summarize_ch
NULL
# > NULL


#' @rdname summarize_ch
#' @export
summarize_at_ch <- function(.tbl, ...) {
  UseMethod("summarize_at_ch")
}

#' @rdname summarize_ch
#' @export
summarize_all_ch <- function(.tbl, ...) {
  UseMethod("summarize_all_ch")
}


#' @rdname summarize_ch
#' @export
summarize_at_ch.eeg_lst <- function(.tbl,.vars,  .funs, ...) {
  #TODO look for a rlang alternative for dplyr:::as_fun_list and dplyr:::tbl_at_syms
  funs <- dplyr:::as_fun_list(.funs, rlang::enquo(.funs), rlang::caller_env(),...) # fun_list class, contains a quosure such as ^mean(.)
  vars <- dplyr:::tbl_at_syms(.tbl, .vars) #list of chars
  summarize_at_eeg_lst(.tbl, vars, funs) 
}

#' @export
summarise_at_ch <- summarize_at_ch

#' @rdname summarize_ch
#' @export
summarize_all_ch.eeg_lst <- function(.tbl, .funs, ...) {
  funs <- dplyr:::as_fun_list(.funs, rlang::enquo(.funs), rlang::caller_env(),...) # fun_list class, contains a quosure such as ^mean(.)
  vars <- as.list(channel_names(.tbl))
  summarize_at_eeg_lst(.tbl, vars, funs) 
}

#' @export
summarise_all_ch <- summarize_all_ch


#' Bind eeg_lst objects.
#'
#' Binds eeg_lst and throws a warning if there is a mismatch in the channel information.
#'
#' @param ... `eeg_lst` objects to combine.
#'
#' @return An `eeg_lst` object.
#'
#' @importFrom magrittr %>%
#'
#' @export
bind <- function(...) {
  eeg_lsts <- list(...)
  # hack to allow that "..." would already be a list
  if (class(eeg_lsts[[1]]) != "eeg_lst") {
    eeg_lsts <- list(...)[[1]]
  }

  # Checks:
  purrr::iwalk(
    eeg_lsts[seq(2, length(eeg_lsts))],
    ~if (!identical(channels_tbl(eeg_lsts[[1]]), channels_tbl(.x))) {
      warning("Objects with different channels information, see below\n\n", "File ",
        as.character(as.numeric(.y) + 1), " ... \n",
        paste0(
          capture.output(setdiff(channels_tbl(eeg_lsts[[1]]), channels_tbl(.x))),
          collapse = "\n"
        ),
        "\n\n ... in comparison with file 1 ...\n\n",
        paste0(
          capture.output(setdiff(channels_tbl(.x), channels_tbl(eeg_lsts[[1]]))),
          collapse = "\n"
        )
        ,
        call. = FALSE
      )
    }
  )

  # Binding
  # .id of the new eggbles needs to be adapted

  signal <- purrr::map(eeg_lsts, ~.x$signal) %>% data.table::rbindlist(idcol=".sid", fill = TRUE)
  signal[, .id := .GRP, by = .(.sid,.id)][,.sid := NULL]
  data.table::setkey(signal,.id,.sample_id)
  
  data.table::setattr(signal,"class",c("signal_tbl",class(signal)))
  events <- purrr::map(eeg_lsts, ~.x$events) %>% data.table::rbindlist(idcol=".sid", fill = TRUE)
  events[, .id := .GRP, by = .(.sid,.id)][,.sid := NULL]


  segments <- purrr::map(eeg_lsts, ~data.table::data.table(.x$segments)) %>% data.table::rbindlist(idcol=".sid", fill = TRUE)
  segments[, .id := .GRP, by = .(.sid,.id)][,.sid := NULL] 
  segments <- segments %>% dplyr::as_tibble()

  new_eeg_lst <- new_eeg_lst(
    signal = signal, events = events, segments = segments
  ) %>%
    validate_eeg_lst()
  message(say_size(new_eeg_lst))
  new_eeg_lst
}
