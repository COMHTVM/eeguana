#' Summarize multiple channels
#' 
#' These are scoped variants of `summarize()` that apply operations on a selection of channels
#
#'
#' * `summarize_at_ch` allows for selecting the channels  using the same name-based select_helpers just like with `select()`.
#' * `summarize_all_ch` summarizes all channels.
#'
#' @param .tbl An eeg_lst object.
#' @param .vars A list of channels generated by vars(), a character vector of channel names, or NULL.
#' @inheritParams dplyr::summarize_at
#' @family summarizing functions
#' @family dplyr functions
#' 
#' @name summarize_ch
NULL
# > NULL


#' @rdname summarize_ch
#' @export
summarize_at_ch <- function(.tbl, ...) {
  UseMethod("summarize_at_ch")
}

#' @rdname summarize_ch
#' @export
summarize_all_ch <- function(.tbl, ...) {
  UseMethod("summarize_all_ch")
}


#' @rdname summarize_ch
#' @export
summarize_at_ch.eeg_lst <- function(.tbl,.vars,  .funs, ...) {
  #TODO look for a rlang alternative for as_fun_list and dplyr:::tbl_at_syms
  funs <- as_fun_list(.funs, rlang::enquo(.funs), rlang::caller_env(),...) # fun_list class, contains a quosure such as ^mean(.)
  vars <- tbl_at_syms(.tbl$.signal, .vars) #list of chars

  is_named <- rlang::quo_text(rlang::enquo(.funs)) %>% 
              stringr::str_detect('have_name = TRUE')

  # if a name wasn't given:
  if(!is_named){
    names(funs) <- NULL
  }

  summarize_at_eeg_lst(.tbl, vars, funs) 
}

#' @rdname summarize_ch
#' @export
summarise_at_ch <- summarize_at_ch

#' @rdname summarize_ch
#' @export
summarize_all_ch.eeg_lst <- function(.tbl, .funs, ...) {
  funs <- as_fun_list(.funs, rlang::enquo(.funs), rlang::caller_env(),...) # fun_list class, contains a quosure such as ^mean(.)
  
  is_named <- rlang::quo_text(rlang::enquo(.funs)) %>% 
              stringr::str_detect('have_name = TRUE')

  # if a name wasn't given:
  if(!is_named){
    names(funs) <- NULL
  }
  
  vars <- as.list(channel_names(.tbl))
  summarize_at_eeg_lst(.tbl, vars, funs) 
}
#' @rdname summarize_ch
#' @export
summarise_all_ch <- summarize_all_ch


#' Bind eeg_lst objects.
#'
#' Binds eeg_lst and throws a warning if there is a mismatch in the channel information.
#'
#' @param ... `eeg_lst` objects to combine.
#'
#' @return An `eeg_lst` object.
#'
#' @importFrom magrittr %>%
#'
#' @export
bind <- function(...) {
  eeg_lsts <- list(...)
  # hack to allow that "..." would already be a list
  if (class(eeg_lsts[[1]]) != "eeg_lst") {
    eeg_lsts <- list(...)[[1]]
  }

  # Checks:
  purrr::iwalk(
    eeg_lsts[seq(2, length(eeg_lsts))],
    ~if (!identical(channels_tbl(eeg_lsts[[1]]), channels_tbl(.x))) {
      warning("Objects with different channels information, see below\n\n", "File ",
        as.character(as.numeric(.y) + 1), " ... \n",
        paste0(
          utils::capture.output(setdiff(channels_tbl(eeg_lsts[[1]]), channels_tbl(.x))),
          collapse = "\n"
        ),
        "\n\n ... in comparison with file 1 ...\n\n",
        paste0(
          utils::capture.output(setdiff(channels_tbl(.x), channels_tbl(eeg_lsts[[1]]))),
          collapse = "\n"
        )
        ,
        call. = FALSE
      )
    }
  )

  # Binding
  # .id of the new eggbles needs to be adapted

  signal <- purrr::map(eeg_lsts, ~.x$.signal) %>% data.table::rbindlist(idcol=".sid", fill = TRUE)
  signal[, .id := .GRP, by = .(.sid,.id)][,.sid := NULL]
  data.table::setkey(signal,.id,.sample)
  
  data.table::setattr(signal,"class",c("signal_tbl",class(signal)))
  events <- purrr::map(eeg_lsts, ~.x$.events) %>% data.table::rbindlist(idcol=".sid", fill = TRUE)
  events[, .id := .GRP, by = .(.sid,.id)][,.sid := NULL]
  events <- as_events_tbl(events)

  segments <- purrr::map(eeg_lsts, ~data.table::data.table(.x$.segments)) %>% data.table::rbindlist(idcol=".sid", fill = TRUE)
  segments[, .id := .GRP, by = .(.sid,.id)][,.sid := NULL] 
  segments <- segments %>% dplyr::as_tibble()

  new_eeg_lst <- new_eeg_lst(
    .signal = signal, .events = events, .segments = segments
  ) %>%
    validate_eeg_lst()
  message(say_size(new_eeg_lst))
  new_eeg_lst
}
