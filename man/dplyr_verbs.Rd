% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dplyr_verbs.R
\name{dplyr_verbs}
\alias{dplyr_verbs}
\alias{mutate.eeg_lst}
\alias{transmute.eeg_lst}
\alias{filter.eeg_lst}
\alias{summarise.eeg_lst}
\alias{group_by.eeg_lst}
\alias{ungroup.eeg_lst}
\alias{select.eeg_lst}
\alias{rename.eeg_lst}
\alias{groups.eeg_lst}
\alias{group_vars.eeg_lst}
\alias{anti_join.eeg_lst}
\alias{left_join.eeg_lst}
\alias{semi_join.eeg_lst}
\title{Dplyr verbs overloaded for manipulating eeg_lst objects.}
\usage{
\method{mutate}{eeg_lst}(.data, ...)

\method{transmute}{eeg_lst}(.data, ...)

\method{filter}{eeg_lst}(.data, ..., .preserve = FALSE)

\method{summarise}{eeg_lst}(.data, ...)

\method{group_by}{eeg_lst}(.data, ..., add = FALSE, .drop = FALSE)

\method{ungroup}{eeg_lst}(.data, ...)

\method{select}{eeg_lst}(.data, ...)

\method{rename}{eeg_lst}(.data, ...)

\method{groups}{eeg_lst}(x)

\method{group_vars}{eeg_lst}(x)

\method{anti_join}{eeg_lst}(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), ...)

\method{left_join}{eeg_lst}(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), ...)

\method{semi_join}{eeg_lst}(x, y, by = NULL, suffix = c(".x", ".y"),
  ...)
}
\arguments{
\item{.data}{An eeg_lst.}

\item{...}{Name-value pairs of expressions; see \link[dplyr:dplyr]{dplyr} for more help.}

\item{.preserve}{Not in use, for compatibility reasons.}

\item{add}{Not in use, for compatibility reasons.}

\item{.drop}{When .drop = TRUE, empty groups are dropped. (FALSE by default.)}

\item{x}{An eeg_lst.}

\item{y}{A data frame, tibble, or data.table.}

\item{by}{a character vector of variables to join by.  If \code{NULL}, the
default, \code{*_join()} will do a natural join, using all variables with
common names across the two tables. A message lists the variables so
that you can check they're right (to suppress the message, simply
explicitly list the variables that you want to join).

To join by different variables on x and y use a named vector.
For example, \code{by = c("a" = "b")} will match \code{x.a} to
\code{y.b}.}

\item{copy}{If \code{x} and \code{y} are not from the same data source,
and \code{copy} is \code{TRUE}, then \code{y} will be copied into the
same src as \code{x}.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.}

\item{suffix}{If there are non-joined duplicate variables in \code{x} and
\code{y}, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.}
}
\value{
An eeg_lst object.
}
\description{
Manipulate the signal table and the segments table of an eeg_lst.
}
\details{
Wrappers for \link[dplyr:dplyr]{dplyr}'s commands that act on different parts
\code{eeg_lst} objects.
The following wrappers have been implemented for \code{eeg_lst} objects:
\itemize{
\item \code{left_join()}: left-joins an external table to the segments table of the eeg_lst.
\item \code{semi_join()}: semi-joins an external table to the segments table of the eeg_lst.
\item \code{anti_join()}: anti-joins an external table to the segments table of the eeg_lst.
\item \code{mutate()} adds new variables and preserves existing ones. Variables that are a function of a channel are added to the signal_tbl table, and other variables are added to the segments table.
\item \code{transmute()} like \code{mutate} but drops non-used variables of the referred table, except for the obligatory columns starting with \code{.}.
\item \code{filter()}: finds segments/samples where conditions are true. Segments/samples where the condition evaluates to NA are dropped.
\item \code{summarize()} summarizes the channel of the signal_tbl table
\item \code{group_by()}: allows that operations would be performed "by group".
\item \code{ungroup()}: removes the grouping created by group_by.
\item \code{select()} keeps only the mentioned variables from the referred table, except for the obligatory columns starting with \code{.}.
\item \code{rename()}: keeps all variables.
}

In addition, \code{_at()}, and \code{_if()} versions of these verbs work as well. Notice that  \code{_at()} versions are much faster than \code{_if()} versions of these commands.

These functions always return the entire \code{eeg_lst} so that
they can be ' piped using \link[magrittr:magrittr]{magrittr} 's pipe, %>%.
}
\examples{
library(dplyr)
# Create new channel in the signal table
data_faces_ERPs \%>\%
  mutate(tmp = Fz - Cz)

# Create a new condition in the segments table
data_faces_ERPs \%>\%
  mutate(code = ifelse(condition == "faces", 1, -1))

# Create a new channel and drop all others
data_faces_ERPs \%>\%
  transmute(Occipital = chs_mean(O1, O2, Oz,
    na.rm = TRUE
  ))

# Extract data associated with a condition
data_faces_ERPs \%>\%
  filter(condition == "faces")

# Group and summarize
data_faces_ERPs \%>\%
  # Convert samples to times, filter between timepoints
  filter(between(
    as_time(.sample, unit = "ms"),
    100, 200
  )) \%>\%
  # Find mean amplitude of Fz for each condition
  group_by(condition) \%>\%
  summarize(mean.amplitude = mean(Fz))

# Select specific electrodes
data_faces_ERPs \%>\%
  select(O1, O2, P7, P8)

# Rename a variable
data_faces_ERPs \%>\%
  rename(Predictor = condition)
}
\concept{dplyr functions}
