---
title: "Introduction - Manipulating a clean EEG file exported from BrainVision 2.0"
author: "Bruno Nicenboim"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Manipulating a clean EEG file exported from BrainVision 2.0}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(width = 80)
```

*eeguana* provides a framework for manipulating EEG data with *dplyr*-based function (e.g., `mutate`, `filter`, `summarize`) extended to a new class `eeg_lst`. In addition, it provides other EEG-specialized functions, and `ggplot` wrapper functions.  The new class is inspired by tidyverse principles but it's not really "tidy" (due to space considerations), it's a list of (i) a wide table (`signal_tbl`) that contains the signal amplitudes at every sample point of the EEG,  (ii) an events table with information about markers (or triggers), blinks and other exported information, and (iii) a long table with experimental information, such as participant (`recording`), conditions, etc.  



Here, I
exemplify the use of *eeguana* with (pre-processed) EEG data from BrainVision 2.0. The data belong to 
a simple experiment  where a
participant was presented 100 faces and 100 assorted images in random order. The
task of the experiment was to mentally count the number of faces.



First we download the data:

```{r downloading, eval = any(!file.exists("faces.dat","faces.vmrk","faces.dat"))}

download.file("http://www.ling.uni-potsdam.de/~nicenboim/files/faces.vhdr", 
               mode="wb", destfile="faces.vhdr")
download.file("http://www.ling.uni-potsdam.de/~nicenboim/files/faces.vmrk", 
               mode="wb", destfile="faces.vmrk")
download.file("http://www.ling.uni-potsdam.de/~nicenboim/files/faces.dat", 
               mode="wb", destfile="faces.dat")
```

BrainVision 2.0 exports three files: `faces.vhdr`, `faces.vmrk`, and
`faces.dat`. The file `faces.vhdr` contains the metadata and links to the other
two files, `faces.vmrk` contains the triggers and other events in the samples,
and `faces.dat` contains the signals at every sample for every channel recorded.


```{r libs, message = FALSE}
library(eeguana)
```

We first need to read the data:

```{r}
faces <- read_vhdr("faces.vhdr")
```

The function `read_vhdr()` creates a list with data frames for the signal, events,
segments information, and incorporates in its attributes generic EEG information.

```{r}
faces
```

It provides a summary:

```{r}
summary(faces)
```

Furthermore, it allows for quick visualization.

```{r, fig.dim = c(10,15), out.width = "100%"}
plot(faces)
```

The standard plots  can be slightly customized using `ggplot` layers.


```{r, fig.dim = c(10,15), out.width = "100%"}
plot(faces) + coord_cartesian(ylim = c(-500,500))
```


Some intervals were marked as "bad" by BrainVision, and so we'll remove them
from the data. We'll also segment and baseline the data. In this experiment, the
trigger "s70" was used for faces and "s71" for no faces. We'll segment the data
using these two triggers.


```{r}
faces_segs <- faces %>% 
               segment(description %in% c("s70", "s71"), 
                        lim = c(-.2,.25)) %>%
               event_to_ch_NA(type == "Bad Interval") %>% 
               ch_baseline()
```


We can also edit the segmentation information and add more descriptive labels.
*eeguana* has wrappers for many `dplyr` commands for the EEG data (see `` ?`dplyr-eeguana` ``).  These commands always return an entire `eeg_lst` object so that they can be piped using `magrittr`'s pipe, `%>%`.

```{r,  fig.dim = c(10,5)}
faces_segs_some <- faces_segs %>%  
                  mutate(condition =
                  if_else(description == "s70", "faces", "non-faces")) %>% 
                  select(-type)

faces_segs_some
```

With some `ggplot` skills, we can create customized plots. `plot_gg`
downsamples the signals (by default), and converts them to a long-format data frame that is
feed into `ggplot` object. This object can then be customized. 


```{r, fig.dim = c(10,10), out.width = "100%"}
faces_segs_some %>% 
                  select(O1, O2, P7, P8) %>% 
                  plot_gg() + 
                  geom_line(alpha = .1, aes(group = .id, color = condition)) + 
                  stat_summary(fun.y = "mean", geom ="line", alpha = 1, size = 1.5, 
                  aes(color = condition)) +
                  facet_wrap(~ channel) + 
                  geom_vline(xintercept = 0, linetype = "dashed") + 
                  geom_vline(xintercept = .17, linetype = "dotted") + 
                  theme(legend.position = "bottom") 
```

The motivation for manipulating the data in the `eeg_lst` format and not transforming
them directly to a data frame has to do with size considerations. In this case,
the original file was 149 MB, converting it to a long format entails a lot of
repetition and generates an object of 786 MB. While this will still work here, a long format quickly becomes prohibitive in real settings with longer recordings and with
several subjects.

We can see here the N170 component in the faces condition for the average trial
on a single participant. We can investigate the signal by averaging the channels
of the occipital and parietal lobes using the capabilities inherited from `dplyr`, and the special function, `chs_mean()`, a wrapper for `rowMeans()`, which takes as arguments the relevant channels and whether missing values should be omitted from the calculations.

                                                              
```{r, fig.dim = c(10,5), out.width = "100%"}
faces_segs_some %>% 
                transmute(Occipital = chs_mean(O1, O2, Oz, na.rm = TRUE),
                          Parietal = chs_mean(P3, P4, P7,  P8, Pz, na.rm = TRUE)) %>% 
                plot_gg() + 
                geom_line(alpha = .1, aes(group = .id, color = condition)) +
                stat_summary(fun.y = "mean", geom ="line", alpha = 1, size = 1, 
                  aes(color = condition)) +
                facet_wrap(~ channel) + 
                theme(legend.position = "bottom") 
```

We can also calculate the ERPs and then plot them in their layout:

```{r layout, fig.dim = c(10,10), out.width = "100%"}
ERP_faces <- faces_segs_some %>% group_by(.sample_id, condition) %>%
    summarize_all_ch(mean,na.rm=TRUE)

ERP_plot <- ERP_faces %>%
                plot_gg() + 
                geom_line(aes(color = condition)) +
               facet_wrap(~ channel) + 
                theme(legend.position = "bottom") + 
  ggtitle("ERPs for faces vs non-faces") 

ERP_plot  %>% plot_in_layout() 
```

Another possibility is to create a topographic plot of the two conditions, by
first making segments that include only the interval .1-.2 *s* after the onset
of the stimuli, creating a table with interpolated amplitudes and using the ggplot wrapper `plot_topo()`.

```{r topo, fig.dim = c(10,5), out.width = "100%"}
faces_segs_some %>% filter(between(as_time(.sample_id, unit = "milliseconds"),100,200)) %>% 
                    group_by(condition) %>%
                    summarize_all_ch(mean, na.rm = TRUE) %>%
                    plot_topo() +
                    annotate_head() + 
                    geom_contour() +
                    geom_text(colour = "black") +
                    facet_grid(~condition)

```



For more specialized plots or analyses, it might be necessary to extract the data  in long data
frame format first. For example, here, we visualize independent t-tests (or some
other statistics) at every electrode and time point. 

```{r}
df <- faces_segs_some %>% 
      select(O1, O2, P7, P8) %>%
      as_tibble %>%
        # We can use regular dplyr functions now
      group_by(channel, time) %>% 
      summarize(
        `t-value` = t.test(amplitude[condition == "faces"],
          amplitude[condition == "non-faces"])$statistic)

df
```

Then we just load the data frame into `ggplot`.

```{r, fig.dim = c(10,10), out.width = "100%"}
ggplot(df, aes(x = time, y = `t-value`)) + geom_line() +
                facet_wrap(~ channel) 
```

However, this can be also done in the without transforming the `eeg_lst` object:

```{r, fig.dim = c(10,10), out.width = "100%"}
faces_segs_some_t <- 
  faces_segs_some %>% 
      select(O1, O2, P7, P8) %>%
      group_by(.sample_id) %>% 
      summarize_all_ch(funs(t = t.test(.[condition == "faces"],
          .[condition == "non-faces"])$statistic))

  plot_gg(faces_segs_some_t) + 
                geom_line(alpha = .1, aes(group = .id)) +
                stat_summary(fun.y = "mean", geom ="line", alpha = 1, size = 1) +
                facet_wrap(~ channel) + 
                theme(legend.position = "bottom") 

```


