---
title: "Preprocessing of EEG data and computing ERPs (Fieldtrip tutorial)"
author: "Bruno Nicenboim"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Preprocessing of EEG data and computing ERPs (Fieldtrip tutorial)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.dim = c(10,15),
  out.width = "100%"
)
```

This tutorial is an adaptation (and some parts are a verbatim copy) of *Fieldtrip*'s [Preprocessing - Reading continuous EEG data](http://www.fieldtriptoolbox.org/tutorial/preprocessing_erp). Fieldtrip is a great MATLAB toolbox for MEG and EEG analysis. Here I show, how we would do a very similar analysis with *eeguana*. (No previous exposure Fieldtrip is needed to follow this vignette). 




The preprocessing of data refers to the reading of the data, segmenting the data around interesting events such as triggers, temporal filtering, and optionally rereferencing.


There are largely two alternative approaches for preprocessing, which especially differ in the amount of memory required (and time). The first approach is to read all data from the file(s) into memory, apply filters, and subsequently cut the data into interesting segments. The second approach is to segment the data and then apply the filters to those segments only. This tutorial explains the second approach.

Preprocessing involves several steps including identifying individual trials from the dataset, filtering and artifact rejections. This tutorial covers how to identify trials using the trigger signal. Defining data segments of interest can be done according to a specified trigger channel or according to your own criteria.


## Dataset

The EEG dataset used in this script is available [here](ftp://ftp.fieldtriptoolbox.org/pub/fieldtrip/tutorial/preprocessing_erp). In the experiment, subjects made positive/negative or animal/human judgments on nouns. The nouns were either positive animals (puppy), negative animals (maggot), positive humans (princess), or negative humans (murderer). The nouns were presented visually (written words). The task cue (which judgment to make) was given with each word.


First we download the data:

```{r downloading,  eval = any(!file.exists("s04.eeg","s04.vmrk","s04.vhdr"))}
download.file("ftp://ftp.fieldtriptoolbox.org/pub/fieldtrip/tutorial/preprocessing_erp/s04.eeg","s04.eeg")
download.file("ftp://ftp.fieldtriptoolbox.org/pub/fieldtrip/tutorial/preprocessing_erp/s04.vhdr","s04.vhdr")
download.file("ftp://ftp.fieldtriptoolbox.org/pub/fieldtrip/tutorial/preprocessing_erp/s04.vmrk","s04.vmrk")
download.file("ftp://ftp.fieldtriptoolbox.org/pub/fieldtrip/tutorial/preprocessing_erp/mpi_customized_acticap64.mat","mpi_customized_acticap64.mat")
```

And then we load the *eeguana* package and read the the `.vhdr` fileinto memory. 
The function `read_vhdr` creates a list with data frames for the signal, events,
segments information, and incorporates in its attributes generic EEG information.

```{r libs, message = FALSE}
library(eeguana)
```

```{r}
data_judg <- read_vhdr(file = "s04.vhdr")
```

## Procedure

### Defining trials

The triggers were defined such that the trigger "S131" indicates condition 1 (positive-negative judgment) and 
 "S132" indicates condition 2 (animal-human judgment).

```{r}
events(data_judg)
```

However, we want the ERP based on the trigger "S141" that precedes any of these two triggers. We edit the events table (using dplyr functions) to indicate to which condition each trigger "S141" belongs, and then we can segment based on these conditions:


```{r}
events(data_judg) <- mutate(events(data_judg), 
                            condition = case_when(description == "S141" &
                                                  lead(description) == "S131" ~ 1 ,
                                                  description == "S141" & 
                                                  lead(description) == "S132" ~ 2, 
                                                                         TRUE ~ 0))
data_judg_s <- data_judg %>% segment(condition %in% c(1,2), lim = c(-0.2,1))

```


## Pre-processing and re-referencing

In this raw BrainVision dataset, the signal from all electrodes is monopolar and referenced to the left mastoid. We want the signal to be referenced to linked (left and right) mastoids. During the acquisition the 'RM' electrode (number 32) had been placed on the right mastoid. In order to re-reference the data (e.g. including also the right mastoid in the reference) we add implicit channel 'REF' to the channels (which represents the left mastoid) by creating a channel with `channel_dbl()` and filling it with zeros. The we re-reference the data using 'REF' and 'RM', the left and right mastoids respectively. Finally we apply a low-pass filter:

```{r}
data_judg_s_p <- data_judg_s %>% 
                # By default from the beginning of each segment to 0:
                ch_baseline() %>% 
                # The reference channel REF is filled with 0  
                mutate(REF = channel_dbl(0)) %>% 
                # All channels are references with REF  
                ch_rereference(RM, REF) %>% 
                # A low pass filter is applied 
                ch_filt_low_pass(100)  
```

We can have a look at one of the trials (the second one) of one channel (channel 11) using `plot()`

```{r}
data_judg_s_p %>% filter(segment == 2) %>% 
                  select(X11) %>% 
                  plot()

```


And we can do more advanced plotting using `plot_gg` (allowing us to display more information):

```{r}
data_judg_s_p %>% select(X11) %>% 
                  plot_gg() + 
                  geom_line(aes(group = segment, color = factor(condition)), alpha = .5) 

```

## Extracting the EOG signals

In the BrainAmp acquisition system, all channels are measured relative to a common reference. For the horizontal EOG we will compute the potential difference between channels 57 and 25 (see the plot of the layout and the figure below). For the vertical EOG we will use channel 53 and channel "LEOG" which was placed below the subjects' left eye.

```{r}

data_judg_s_p <- data_judg_s_p %>% 
                 mutate(eogv = ch_rereference(x = LEOG, X53),
                        eogh = ch_rereference(x = X25, X57)) %>%
                 # Unnecessary channels are removed
                 select(-LEOG, -X53, -X56, -X25) 

```

You can check the channel labels that are now present in the data:
 

```{r}
channels_tbl(data_judg_s_p) %>% print(n=100)

```

<!-- ## Channel layout

For topoplotting and sometimes for analysis it is necessary to know how the electrodes were positioned on the scalp. In contrast to the sensor arrangement from a given MEG manufacturer, the topographical arrangement of the channels in EEG is not fixed. Different acquisition systems are designed for different electrode montages, and the number and position of electrodes can be adjusted depending on the experimental goal. In the current experiment, so-called 64-electrodes equidistant montage (ActiCap, BrainVision) was used. 

The channel positions are not always stored in the EEG dataset. But we can use a fieldtrip layout file; this is a .mat file that contains the 2-D positions of the channels. (FieldTrip provides a number of default layouts for BrainVision EEG caps in the fieldtrip/template/layout directory.) It is also possible to edit the `channels_tbl` manually. In this example we will use an existing layout.


```{r}
layout <- read_layout(mpi_customized_acticap64.mat)

```

Note that the layout should contain correct channel labels that match the channel labels in the data (channel labels not present in either will not be plotted when using a given layout). 
 -->

## Artifacts

A next important step of EEG preprocessing is detection (and rejection) of artifacts. We can plot 
EOG channel ('veog', number 61) and confirm that the segments 22, 42, 126, 136 and 150 contain blinks. 



```{r}
data_judg_s_p %>%  select(eogv) %>% 
                   plot_gg() + 
                   geom_line() + 
                   facet_wrap(~segment)

```

The data can be also displayed in a different way :

```{r, results = "hold"}
data_judg_s_p %>%  group_by(segment) %>% summarize_all_ch(var) %>% 
                   plot_gg(x = segment, y= channel, fill = amplitude) + 
                   geom_raster() 

data_judg_s_p %>%  summarize_all_ch(var) %>% 
                   plot_gg(x = amplitude, y= channel) + 
                   geom_point() 

data_judg_s_p %>% chs_fun(var) %>% 
                   plot_gg(x = amplitude, y= channel) + 
                   geom_point() 
```

<!-- 

  group_by(segment) %>%
                  summarize(chs_fun(vars or vector of characters, .funs = var))

                  #ch_fun ignore the grouping

 -->


 You can also plot the signal in a specific trial with “Plot trial” box. Here, we have plotted the trial 90 - the one with the highest variance. We can see a drift in the channel 48. You can zoom in to this channel by dragging the mouse over it.


```{r, results = "hold"}
data_judg_s_p %>% filter(segment ==90)  %>% 
                  plot() + 
                  facet_wrap(~channel)

data_judg_s_p %>% filter(segment ==90) %>% 
                  select(X48) %>% 
                  plot()

```


Rejection of trials based on visual inspection is somewhat arbitrary. Sometimes it is not easy to decide if a trial has to be rejected or not. In this exercise we suggest that you remove 8 trials with the highest variance (trial numbers 22, 42, 89, 90, 92, 126, 136 and 150). As you see, the trials with blinks that we saw in the “Channel” mode are among them. To complete the rejection press “Quit” button. You get the data_clean variable that will be used for subsequent analyses. 

```{r}

data_judg_s_p <- data_judg_s_p %>% 
                filter(!segment %in% c(22, 42, 89, 90, 92, 126, 136, 150))
```


## Computing and plotting the ERP's

We now would like to compute the ERP's for two conditions: positive-negative judgment and human-animal judgment. This is straightforward to do with `group_by` and `summarize_*`.


```{r}

ERPs <- data_judg_s_p %>% 
        group_by(.sample_id, condition) %>% 
        summarize_all_ch(mean,na.rm=TRUE)

ERPs   %>% plot_gg() + 
           geom_line(aes(color = factor(condition))) + 
           facet_wrap(~channel)
```

 The following code allows you to look at the ERP difference waves. 


```{r}

diff_ERPs <- data_judg_s_p %>% 
             group_by(.sample_id) %>% 
             summarize_all_ch(funs(
                  mean(.[condition==1] - .[condition==2], 
                       na.rm=TRUE)))

diff_ERPs  %>% plot_gg() +
               geom_line() + 
               facet_wrap(~channel)
```



